create type "public"."visibility" as enum ('public', 'unlisted', 'private');

create table "public"."live_events" (
    "id" uuid not null default gen_random_uuid(),
    "created_at" timestamp with time zone not null default now(),
    "game" uuid not null,
    "user_id" uuid,
    "event_type" text not null,
    "payload" jsonb
);


alter table "public"."live_events" enable row level security;

create table "public"."live_games" (
    "id" uuid not null,
    "created_at" timestamp with time zone not null default now(),
    "host" uuid not null default auth.uid()
);


alter table "public"."live_games" enable row level security;

create table "public"."live_rooms" (
    "code" text not null,
    "id" uuid not null
);


alter table "public"."live_rooms" enable row level security;

create table "public"."profiles" (
    "id" uuid not null,
    "display_name" text,
    "username" text not null,
    "last_updated" timestamp with time zone not null default now()
);


alter table "public"."profiles" enable row level security;

create table "public"."quizzes" (
    "id" bigint generated by default as identity not null,
    "author" uuid not null,
    "title" text not null,
    "quiz_description" text not null default ''::text,
    "visibility" visibility not null default 'public'::visibility,
    "copy_protect" boolean not null,
    "thumbnail" jsonb,
    "contents" jsonb not null,
    "created_at" timestamp with time zone not null default now(),
    "last_updated" timestamp with time zone not null default now()
);


alter table "public"."quizzes" enable row level security;

create table "public"."user_image_uploads" (
    "id" bigint generated by default as identity not null,
    "author" uuid not null default auth.uid(),
    "media_path" text[] not null,
    "file_name" text not null,
    "created_at" timestamp with time zone not null default now()
);


alter table "public"."user_image_uploads" enable row level security;

CREATE UNIQUE INDEX live_events_pkey ON public.live_events USING btree (id);

CREATE UNIQUE INDEX live_games_pkey ON public.live_games USING btree (id);

CREATE UNIQUE INDEX live_rooms_pkey ON public.live_rooms USING btree (code);

CREATE UNIQUE INDEX profiles_pkey ON public.profiles USING btree (id);

CREATE UNIQUE INDEX profiles_useranem_key ON public.profiles USING btree (username);

CREATE UNIQUE INDEX quizzes_id_key ON public.quizzes USING btree (id);

CREATE UNIQUE INDEX quizzes_pkey ON public.quizzes USING btree (id);

CREATE UNIQUE INDEX user_image_uploads_pkey ON public.user_image_uploads USING btree (id);

alter table "public"."live_events" add constraint "live_events_pkey" PRIMARY KEY using index "live_events_pkey";

alter table "public"."live_games" add constraint "live_games_pkey" PRIMARY KEY using index "live_games_pkey";

alter table "public"."live_rooms" add constraint "live_rooms_pkey" PRIMARY KEY using index "live_rooms_pkey";

alter table "public"."profiles" add constraint "profiles_pkey" PRIMARY KEY using index "profiles_pkey";

alter table "public"."quizzes" add constraint "quizzes_pkey" PRIMARY KEY using index "quizzes_pkey";

alter table "public"."user_image_uploads" add constraint "user_image_uploads_pkey" PRIMARY KEY using index "user_image_uploads_pkey";

alter table "public"."live_events" add constraint "live_events_game_fkey" FOREIGN KEY (game) REFERENCES live_games(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."live_events" validate constraint "live_events_game_fkey";

alter table "public"."live_games" add constraint "live_games_host_fkey" FOREIGN KEY (host) REFERENCES profiles(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."live_games" validate constraint "live_games_host_fkey";

alter table "public"."live_rooms" add constraint "live_rooms_id_fkey" FOREIGN KEY (id) REFERENCES live_games(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."live_rooms" validate constraint "live_rooms_id_fkey";

alter table "public"."profiles" add constraint "profiles_id_fkey" FOREIGN KEY (id) REFERENCES auth.users(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."profiles" validate constraint "profiles_id_fkey";

alter table "public"."profiles" add constraint "profiles_useranem_key" UNIQUE using index "profiles_useranem_key";

alter table "public"."quizzes" add constraint "quizzes_author_fkey" FOREIGN KEY (author) REFERENCES profiles(id) ON UPDATE CASCADE ON DELETE RESTRICT not valid;

alter table "public"."quizzes" validate constraint "quizzes_author_fkey";

alter table "public"."quizzes" add constraint "quizzes_id_key" UNIQUE using index "quizzes_id_key";

alter table "public"."user_image_uploads" add constraint "user_image_uploads_author_fkey" FOREIGN KEY (author) REFERENCES profiles(id) ON UPDATE CASCADE ON DELETE RESTRICT not valid;

alter table "public"."user_image_uploads" validate constraint "user_image_uploads_author_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.create_profile_for_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
declare generated_username text;
BEGIN generated_username := public.generate_username_from_email(NEW.email);
INSERT INTO public.profiles (id, display_name, username)
VALUES (NEW.id, generated_username, generated_username);
RETURN NEW;
END;
$function$
;
create trigger create_profile_from_auth
after
insert on auth.users for each row execute function public.create_profile_for_new_user();

CREATE OR REPLACE FUNCTION public.delete_quiz(loq_id bigint)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
BEGIN
  IF not exists(
    select 1
    from public.quizzes
    where author = auth.uid()
      and id = loq_id
  ) then
    raise exception sqlstate '90103' using message = 'You are not the owner of this loq.';
  end if;
  delete from public.quizzes where id = loq_id;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.generate_username_from_email(email text)
 RETURNS text
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
declare username_attempt TEXT;
replaced_email TEXT;
BEGIN replaced_email := replace(email, '+', '');
username_attempt := substring(
  replaced_email,
  1,
  POSITION('@' IN replaced_email) -1
);
if public.username_is_invalid (username_attempt) then -- loop_attempt:
loop username_attempt := 'user_' || to_char(trunc(random() * 100000000), 'FM00000000');
if not public.username_is_invalid (username_attempt) then exit;
end if;
end loop;
end if;
return username_attempt;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_user_info(user_id uuid)
 RETURNS json
 LANGUAGE sql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
select coalesce(
    (
      select json_build_object(
          'id',
          id,
          'display_name',
          display_name,
          'username',
          username
        )
      FROM public.profiles
      where id = user_id
    ),
    json_build_object(
      'id',
      user_id,
      'display_name',
      'Unknown User',
      'username',
      'deleted'
    )
  ) $function$
;

CREATE OR REPLACE FUNCTION public.is_hosting(room_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
BEGIN
  return exists(select 1 from public.live_games where id = room_id and host = auth.uid());
end;
$function$
;

CREATE OR REPLACE FUNCTION public.live_create_room()
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
declare room_code TEXT;
declare room_id UUID;
BEGIN
if auth.role() != 'authenticated' then raise exception sqlstate '90200' using message = 'You must be signed in to host a loq!'; end if;
  if exists(
    select 1
    from public.live_games
    where host = auth.uid()
  ) then
    raise exception sqlstate '90201' using message = 'You are already hosting a game!';
  end if;
  room_code := public.live_generate_room_code();
  room_id := gen_random_uuid();
  insert into public.live_games (
    id
  ) values (
    room_id
  );
  insert into public.live_rooms (
    code,
    id
  ) values (
    room_code,
    room_id
  );
  insert into public.live_events (
    game,
    event_type
  ) values (
    room_id,
    'game_create'
  );
  return json_build_object(
          'id',
          room_id,
          'code',
          room_code
  );
end;
$function$
;

CREATE OR REPLACE FUNCTION public.live_generate_room_code()
 RETURNS text
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$
declare room_code_attempt text;
BEGIN
  loop
    room_code_attempt := to_char(trunc(random() * 90000 + 10000), 'FM00000');
    if not 
      exists(select 1 from public.live_rooms where code = room_code_attempt) then exit;
    end if;
  end loop;
  return room_code_attempt;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.live_get_room_id(room_code text)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
declare room_id uuid;
BEGIN
  select id from public.live_rooms where code = room_code into room_id;
  if room_id is null then
    raise exception sqlstate '90301' using message = 'Could not find the specified room code.';
  end if;
  return room_id;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.live_join_room(display_name text, room_id uuid)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
declare new_user_id uuid;
user_join_payload json;
BEGIN
  display_name := trim(display_name);
  if length(display_name) < 1 or length(display_name) > 20 then
    raise exception sqlstate '90302' using message = 'Your name must be 1-20 characters long.';
  end if;
  if not exists (
    select 1 from public.live_games
    where id = room_id
  ) then
   raise exception sqlstate '90304' using message = 'No room with the given ID was found.';
  end if;
  if exists(
    select 1 from public.live_events
    where game = room_id
    and event_type = 'user_join'
    and lower(payload#>>'{display_name}') = lower(display_name)
  ) then
    raise exception sqlstate '90303' using message = 'A user with this name already exists!';
  end if;
  new_user_id := gen_random_uuid();
  user_join_payload := json_build_object(
    'user_id', new_user_id,
    'display_name', display_name
  );
  insert into public.live_events (
    game,
    user_id,
    event_type,
    payload
  ) values (
    room_id,
    new_user_id,
    'user_join',
    user_join_payload
  );
  return user_join_payload;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.live_remove_room(room_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$
BEGIN
  delete from public.live_games where id = room_id;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.live_submit_answer(submitter_user_id uuid, room_id uuid, answer_content json)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
BEGIN 

if not exists (
  select 1
  from public.live_games
  where id = room_id
) then raise exception sqlstate '90304' using message = 'No room with the given ID was found.';
end if;
if not exists(
  select 1
  from public.live_events
  where game = room_id
    and event_type = 'user_join'
    and (payload#>>'{user_id}')::uuid = submitter_user_id
) then raise exception sqlstate '90305' using message = 'You are not a member of this room.';
end if;
insert into public.live_events (
    game,
    user_id,
    event_type,
    payload
  )
values (
    room_id,
    submitter_user_id,
    'user_answer',
    answer_content
  );
end;
$function$
;

CREATE OR REPLACE FUNCTION public.remove_loq_image(upload_id bigint)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
BEGIN
if auth.role() != 'authenticated' then raise exception sqlstate '90100' using message = 'You must be signed in to remove an image!';
end if;

if not exists (select 1 from public.user_image_uploads where id = upload_id and author = auth.uid())
then
  raise exception sqlstate '90105' using message = 'You cannot remove this image.';
end if;

delete from public.user_image_uploads where id = upload_id and author = auth.uid();
end;
$function$
;

CREATE OR REPLACE FUNCTION public.search_public_quizzes(page_number bigint, search_query_string text)
 RETURNS bigint[]
 LANGUAGE plpgsql
AS $function$
declare
match_ids int8[];
BEGIN

if search_query_string = '' then
select array_agg(id) into match_ids from (
  select id
  from public.quizzes
  where
    visibility = 'public' order by last_updated desc
  limit 10 offset page_number * 10
) as sub;
else
select array_agg(id) into match_ids from (
  select id
  from public.quizzes
  where
    visibility = 'public' and
    to_tsvector(title || ' ' || quiz_description) @@ to_tsquery(search_query_string)
  order by last_updated desc
  limit 10 offset page_number * 10
) as sub;

end if;
  RAISE NOTICE 'Page: %, Offset: %', page_number, page_number * 10;


  return match_ids;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.stop_hosting()
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
declare
room_id uuid;
BEGIN
if auth.role() != 'authenticated' then raise exception sqlstate '90300' using message = 'You are not signed in.'; end if;
select id from public.live_games where host = auth.uid() into room_id;
if room_id is null then return; end if;
PERFORM public.live_remove_room(room_id);
end;
$function$
;

CREATE OR REPLACE FUNCTION public.update_username(new_username text)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$ BEGIN if public.username_exists(new_username) then RAISE EXCEPTION SQLSTATE '90000' using message = 'This username is taken.';
end if;
if public.username_is_invalid(new_username) then RAISE EXCEPTION SQLSTATE '90001' using message = 'This username is invalid.';
end if;
update public.profiles
set username = new_username
where id = auth.uid();
end;
$function$
;

CREATE OR REPLACE FUNCTION public.upload_loq(loq_id bigint, loq_contents json)
 RETURNS bigint
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
declare now_timestamp TIMESTAMP;
upload_cutoff TIMESTAMP;
new_id int8;
recent_count int;
BEGIN if auth.role() != 'authenticated' then raise exception sqlstate '90100' using message = 'You must be signed in to upload a loq!';
end if;
now_timestamp := NOW();
upload_cutoff := now_timestamp - INTERVAL '15 minutes';
SELECT COUNT(*) into recent_count
FROM public.quizzes
WHERE quizzes.created_at > upload_cutoff
  and quizzes.author = auth.uid();
if recent_count >= 5 then RAISE EXCEPTION SQLSTATE '90101' using message = 'You have uploaded 5 loqs in the past 15 minutes. Please wait a few minutes before uploading another loq.';
end if;
if (
  (loq_id is null)
  or not exists(
    select 1
    from public.quizzes
    where author = auth.uid()
      and id = loq_id
  )
) then
insert into public.quizzes (
    author,
    title,
    quiz_description,
    visibility,
    copy_protect,
    thumbnail,
    contents,
    last_updated
  )
VALUES (
    auth.uid(),
    loq_contents#>>'{settings,title}',
    loq_contents#>>'{settings,description}',
    (loq_contents#>>'{settings,options,visibility}')::public.visibility,
    (loq_contents#>>'{settings,options,copyProtect}')::boolean,
    to_jsonb(loq_contents#>>'{settings,thumbnail}'),
    loq_contents,
    NOW()
  )
returning id into new_id;
return new_id;
else
update public.quizzes
set title = loq_contents#>>'{settings,title}',
  quiz_description = loq_contents#>>'{settings,description}',
  visibility = (loq_contents#>>'{settings,options,visibility}')::public.visibility,
  copy_protect = (loq_contents#>>'{settings,options,copyProtect}')::boolean,
  thumbnail = (to_jsonb(loq_contents#>>'{settings,thumbnail}')),
  contents = loq_contents,
  last_updated = NOW()
where id = loq_id
returning id into new_id;
if new_id is null then raise exception sqlstate '90102' using message = 'No such loq found for update.';
end if;
return new_id;
end if;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.upload_loq_image(user_file_name text)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
declare
recent_count int;
now_timestamp TIMESTAMP;
upload_cutoff TIMESTAMP;
user_media_path text[];
media_id uuid;
BEGIN
if auth.role() != 'authenticated' then raise exception sqlstate '90100' using message = 'You must be signed in to upload an image!';
end if;

now_timestamp := NOW();
upload_cutoff := now_timestamp - INTERVAL '10 minutes';
SELECT COUNT(*) into recent_count
FROM public.user_image_uploads
WHERE user_image_uploads.created_at > upload_cutoff
  and user_image_uploads.author = auth.uid();
if recent_count >= 10 then RAISE EXCEPTION SQLSTATE '90101' using message = 'You have uploaded 10 images in the past 10 minutes. Please wait a few minutes before uploading another loq.';
end if;

media_id := gen_random_uuid();

user_media_path := ARRAY['media', media_id::text];

if length(user_file_name) > 64 or user_file_name ~ '/[^A-Za-z0-9\-\_\.]/' then
raise exception sqlstate '90104' using message = 'Your file name does not meet the requirements.';
end if;

insert into public.user_image_uploads
(
  media_path,
  file_name
) values (
  user_media_path,
  user_file_name
);

return json_build_object(
  'media_path', user_media_path,
  'file_name', user_file_name
);

end;
$function$
;

CREATE OR REPLACE FUNCTION public.username_exists(username_new text)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$ BEGIN return EXISTS(
    SELECT 1
    FROM public.profiles
    WHERE LOWER(username) = LOWER(username_new)
      and id <> auth.uid()
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.username_is_invalid(username_new text)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$ BEGIN return public.username_exists(username_new)
  or username_new ~ '[^a-zA-Z0-9_\-\.]|^_|_$|[-_\.]{2}'
  or length(username_new) > 16
  OR length(username_new) < 3;
END;
$function$
;

grant delete on table "public"."live_events" to "anon";

grant insert on table "public"."live_events" to "anon";

grant references on table "public"."live_events" to "anon";

grant select on table "public"."live_events" to "anon";

grant trigger on table "public"."live_events" to "anon";

grant truncate on table "public"."live_events" to "anon";

grant update on table "public"."live_events" to "anon";

grant delete on table "public"."live_events" to "authenticated";

grant insert on table "public"."live_events" to "authenticated";

grant references on table "public"."live_events" to "authenticated";

grant select on table "public"."live_events" to "authenticated";

grant trigger on table "public"."live_events" to "authenticated";

grant truncate on table "public"."live_events" to "authenticated";

grant update on table "public"."live_events" to "authenticated";

grant delete on table "public"."live_events" to "service_role";

grant insert on table "public"."live_events" to "service_role";

grant references on table "public"."live_events" to "service_role";

grant select on table "public"."live_events" to "service_role";

grant trigger on table "public"."live_events" to "service_role";

grant truncate on table "public"."live_events" to "service_role";

grant update on table "public"."live_events" to "service_role";

grant delete on table "public"."live_games" to "anon";

grant insert on table "public"."live_games" to "anon";

grant references on table "public"."live_games" to "anon";

grant select on table "public"."live_games" to "anon";

grant trigger on table "public"."live_games" to "anon";

grant truncate on table "public"."live_games" to "anon";

grant update on table "public"."live_games" to "anon";

grant delete on table "public"."live_games" to "authenticated";

grant insert on table "public"."live_games" to "authenticated";

grant references on table "public"."live_games" to "authenticated";

grant select on table "public"."live_games" to "authenticated";

grant trigger on table "public"."live_games" to "authenticated";

grant truncate on table "public"."live_games" to "authenticated";

grant update on table "public"."live_games" to "authenticated";

grant delete on table "public"."live_games" to "service_role";

grant insert on table "public"."live_games" to "service_role";

grant references on table "public"."live_games" to "service_role";

grant select on table "public"."live_games" to "service_role";

grant trigger on table "public"."live_games" to "service_role";

grant truncate on table "public"."live_games" to "service_role";

grant update on table "public"."live_games" to "service_role";

grant delete on table "public"."live_rooms" to "anon";

grant insert on table "public"."live_rooms" to "anon";

grant references on table "public"."live_rooms" to "anon";

grant select on table "public"."live_rooms" to "anon";

grant trigger on table "public"."live_rooms" to "anon";

grant truncate on table "public"."live_rooms" to "anon";

grant update on table "public"."live_rooms" to "anon";

grant delete on table "public"."live_rooms" to "authenticated";

grant insert on table "public"."live_rooms" to "authenticated";

grant references on table "public"."live_rooms" to "authenticated";

grant select on table "public"."live_rooms" to "authenticated";

grant trigger on table "public"."live_rooms" to "authenticated";

grant truncate on table "public"."live_rooms" to "authenticated";

grant update on table "public"."live_rooms" to "authenticated";

grant delete on table "public"."live_rooms" to "service_role";

grant insert on table "public"."live_rooms" to "service_role";

grant references on table "public"."live_rooms" to "service_role";

grant select on table "public"."live_rooms" to "service_role";

grant trigger on table "public"."live_rooms" to "service_role";

grant truncate on table "public"."live_rooms" to "service_role";

grant update on table "public"."live_rooms" to "service_role";

grant delete on table "public"."profiles" to "anon";

grant insert on table "public"."profiles" to "anon";

grant references on table "public"."profiles" to "anon";

grant select on table "public"."profiles" to "anon";

grant trigger on table "public"."profiles" to "anon";

grant truncate on table "public"."profiles" to "anon";

grant update on table "public"."profiles" to "anon";

grant delete on table "public"."profiles" to "authenticated";

grant insert on table "public"."profiles" to "authenticated";

grant references on table "public"."profiles" to "authenticated";

grant select on table "public"."profiles" to "authenticated";

grant trigger on table "public"."profiles" to "authenticated";

grant truncate on table "public"."profiles" to "authenticated";

grant update on table "public"."profiles" to "authenticated";

grant delete on table "public"."profiles" to "service_role";

grant insert on table "public"."profiles" to "service_role";

grant references on table "public"."profiles" to "service_role";

grant select on table "public"."profiles" to "service_role";

grant trigger on table "public"."profiles" to "service_role";

grant truncate on table "public"."profiles" to "service_role";

grant update on table "public"."profiles" to "service_role";

grant delete on table "public"."quizzes" to "anon";

grant insert on table "public"."quizzes" to "anon";

grant references on table "public"."quizzes" to "anon";

grant select on table "public"."quizzes" to "anon";

grant trigger on table "public"."quizzes" to "anon";

grant truncate on table "public"."quizzes" to "anon";

grant update on table "public"."quizzes" to "anon";

grant delete on table "public"."quizzes" to "authenticated";

grant insert on table "public"."quizzes" to "authenticated";

grant references on table "public"."quizzes" to "authenticated";

grant select on table "public"."quizzes" to "authenticated";

grant trigger on table "public"."quizzes" to "authenticated";

grant truncate on table "public"."quizzes" to "authenticated";

grant update on table "public"."quizzes" to "authenticated";

grant delete on table "public"."quizzes" to "service_role";

grant insert on table "public"."quizzes" to "service_role";

grant references on table "public"."quizzes" to "service_role";

grant select on table "public"."quizzes" to "service_role";

grant trigger on table "public"."quizzes" to "service_role";

grant truncate on table "public"."quizzes" to "service_role";

grant update on table "public"."quizzes" to "service_role";

grant delete on table "public"."user_image_uploads" to "anon";

grant insert on table "public"."user_image_uploads" to "anon";

grant references on table "public"."user_image_uploads" to "anon";

grant select on table "public"."user_image_uploads" to "anon";

grant trigger on table "public"."user_image_uploads" to "anon";

grant truncate on table "public"."user_image_uploads" to "anon";

grant update on table "public"."user_image_uploads" to "anon";

grant delete on table "public"."user_image_uploads" to "authenticated";

grant insert on table "public"."user_image_uploads" to "authenticated";

grant references on table "public"."user_image_uploads" to "authenticated";

grant select on table "public"."user_image_uploads" to "authenticated";

grant trigger on table "public"."user_image_uploads" to "authenticated";

grant truncate on table "public"."user_image_uploads" to "authenticated";

grant update on table "public"."user_image_uploads" to "authenticated";

grant delete on table "public"."user_image_uploads" to "service_role";

grant insert on table "public"."user_image_uploads" to "service_role";

grant references on table "public"."user_image_uploads" to "service_role";

grant select on table "public"."user_image_uploads" to "service_role";

grant trigger on table "public"."user_image_uploads" to "service_role";

grant truncate on table "public"."user_image_uploads" to "service_role";

grant update on table "public"."user_image_uploads" to "service_role";

create policy "Allow user to view hosted events"
on "public"."live_events"
as permissive
for select
to public
using (is_hosting(game));


create policy "Allow user to view hosted rooms"
on "public"."live_games"
as permissive
for select
to public
using ((host = auth.uid()));


create policy "Allow users to view own profile"
on "public"."profiles"
as permissive
for select
to authenticated
using ((id = auth.uid()));


create policy "Allow users to view own loqs"
on "public"."quizzes"
as permissive
for select
to public
using ((author = auth.uid()));


create policy "Allow users to view public loqs"
on "public"."quizzes"
as permissive
for select
to public
using ((visibility = 'public'::visibility));


create policy "Allow users to view own uploads"
on "public"."user_image_uploads"
as permissive
for select
to authenticated
using ((author = auth.uid()));



